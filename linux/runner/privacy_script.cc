#include "privacy_script.h"
#include <glib.h>
#include <string.h>

gchar* generate_privacy_script(struct FingerprintProfile *profile) {
  if (!profile) return NULL;
  
  // Build languages array string
  GString *langs_str = g_string_new("[");
  for (gint i = 0; i < profile->languages_count; i++) {
    if (i > 0) g_string_append(langs_str, ", ");
    g_string_append_printf(langs_str, "'%s'", profile->languages[i]);
  }
  g_string_append(langs_str, "]");
  
  // Generate comprehensive privacy script
  gchar *script = g_strdup_printf(
    "(function() {\n"
    "  'use strict';\n"
    "  \n"
    "  // Profile configuration\n"
    "  const PROFILE = {\n"
    "    userAgent: '%s',\n"
    "    platform: '%s',\n"
    "    hardwareConcurrency: %d,\n"
    "    deviceMemory: %d,\n"
    "    languages: %s,\n"
    "    language: '%s',\n"
    "    maxTouchPoints: %d,\n"
    "    vendor: '%s',\n"
    "    screenWidth: %d,\n"
    "    screenHeight: %d,\n"
    "    screenAvailWidth: %d,\n"
    "    screenAvailHeight: %d,\n"
    "    devicePixelRatio: %.2f,\n"
    "    colorDepth: %d,\n"
    "    timezone: '%s',\n"
    "    webglVendor: '%s',\n"
    "    webglRenderer: '%s',\n"
    "    canvasSeed: %u,\n"
    "    audioSeed: %u\n"
    "  };\n"
    "  \n"
    "  // ========== Navigator Properties ==========\n"
    "  try {\n"
    "    Object.defineProperty(navigator, 'userAgent', {\n"
    "      get: () => PROFILE.userAgent,\n"
    "      configurable: true\n"
    "    });\n"
    "    Object.defineProperty(navigator, 'appVersion', {\n"
    "      get: () => PROFILE.userAgent.substring(8),\n"
    "      configurable: true\n"
    "    });\n"
    "    Object.defineProperty(navigator, 'platform', {\n"
    "      get: () => PROFILE.platform,\n"
    "      configurable: true\n"
    "    });\n"
    "    Object.defineProperty(navigator, 'hardwareConcurrency', {\n"
    "      get: () => PROFILE.hardwareConcurrency,\n"
    "      configurable: true\n"
    "    });\n"
    "    Object.defineProperty(navigator, 'deviceMemory', {\n"
    "      get: () => PROFILE.deviceMemory,\n"
    "      configurable: true\n"
    "    });\n"
    "    Object.defineProperty(navigator, 'languages', {\n"
    "      get: () => PROFILE.languages,\n"
    "      configurable: true\n"
    "    });\n"
    "    Object.defineProperty(navigator, 'language', {\n"
    "      get: () => PROFILE.language,\n"
    "      configurable: true\n"
    "    });\n"
    "    Object.defineProperty(navigator, 'maxTouchPoints', {\n"
    "      get: () => PROFILE.maxTouchPoints,\n"
    "      configurable: true\n"
    "    });\n"
    "    Object.defineProperty(navigator, 'vendor', {\n"
    "      get: () => PROFILE.vendor,\n"
    "      configurable: true\n"
    "    });\n"
    "    \n"
    "    // Block plugins and mimeTypes enumeration\n"
    "    Object.defineProperty(navigator, 'plugins', {\n"
    "      get: () => [],\n"
    "      configurable: true\n"
    "    });\n"
    "    Object.defineProperty(navigator, 'mimeTypes', {\n"
    "      get: () => [],\n"
    "      configurable: true\n"
    "    });\n"
    "    \n"
    "    // Spoof other navigator properties\n"
    "    Object.defineProperty(navigator, 'doNotTrack', {\n"
    "      get: () => '1',\n"
    "      configurable: true\n"
    "    });\n"
    "    Object.defineProperty(navigator, 'cookieEnabled', {\n"
    "      get: () => true,\n"
    "      configurable: true\n"
    "    });\n"
    "  } catch(e) { console.error('Navigator override failed:', e); }\n"
    "  \n"
    "  // ========== Screen Properties ==========\n"
    "  try {\n"
    "    const fakeScreen = {\n"
    "      width: PROFILE.screenWidth,\n"
    "      height: PROFILE.screenHeight,\n"
    "      availWidth: PROFILE.screenAvailWidth,\n"
    "      availHeight: PROFILE.screenAvailHeight,\n"
    "      colorDepth: PROFILE.colorDepth,\n"
    "      pixelDepth: PROFILE.colorDepth,\n"
    "      orientation: screen.orientation\n"
    "    };\n"
    "    Object.defineProperty(window, 'screen', {\n"
    "      get: () => fakeScreen,\n"
    "      configurable: true\n"
    "    });\n"
    "    Object.defineProperty(window, 'devicePixelRatio', {\n"
    "      get: () => PROFILE.devicePixelRatio,\n"
    "      configurable: true\n"
    "    });\n"
    "  } catch(e) { console.error('Screen override failed:', e); }\n"
    "  \n"
    "  // ========== Timezone Spoofing ==========\n"
    "  try {\n"
    "    const OriginalDate = Date;\n"
    "    const OriginalIntl = Intl;\n"
    "    \n"
    "    // Override Intl.DateTimeFormat\n"
    "    Intl.DateTimeFormat = function(...args) {\n"
    "      const dtf = new OriginalIntl.DateTimeFormat(...args);\n"
    "      const originalResolvedOptions = dtf.resolvedOptions.bind(dtf);\n"
    "      dtf.resolvedOptions = function() {\n"
    "        const options = originalResolvedOptions();\n"
    "        options.timeZone = PROFILE.timezone;\n"
    "        return options;\n"
    "      };\n"
    "      return dtf;\n"
    "    };\n"
    "    Intl.DateTimeFormat.prototype = OriginalIntl.DateTimeFormat.prototype;\n"
    "  } catch(e) { console.error('Timezone override failed:', e); }\n"
    "  \n"
    "  // ========== Canvas Fingerprinting Protection ==========\n"
    "  try {\n"
    "    const originalToDataURL = HTMLCanvasElement.prototype.toDataURL;\n"
    "    const originalToBlob = HTMLCanvasElement.prototype.toBlob;\n"
    "    const originalGetImageData = CanvasRenderingContext2D.prototype.getImageData;\n"
    "    \n"
    "    // Deterministic noise function based on seed\n"
    "    function addCanvasNoise(canvas, seed) {\n"
    "      try {\n"
    "        const ctx = canvas.getContext('2d');\n"
    "        if (!ctx) return;\n"
    "        \n"
    "        const width = canvas.width;\n"
    "        const height = canvas.height;\n"
    "        if (width === 0 || height === 0 || width * height > 10000000) return;\n"
    "        \n"
    "        const imageData = ctx.getImageData(0, 0, width, height);\n"
    "        const data = imageData.data;\n"
    "        \n"
    "        // Add minimal noise to prevent detection\n"
    "        // Use seed for deterministic but unique noise per profile\n"
    "        let rng = seed;\n"
    "        for (let i = 0; i < data.length; i += 1000) {\n"
    "          rng = (rng * 9301 + 49297) %% 233280;\n"
    "          const noise = (rng / 233280.0) - 0.5;\n"
    "          data[i] = Math.max(0, Math.min(255, data[i] + noise));\n"
    "        }\n"
    "        \n"
    "        ctx.putImageData(imageData, 0, 0);\n"
    "      } catch(e) {}\n"
    "    }\n"
    "    \n"
    "    HTMLCanvasElement.prototype.toDataURL = function(...args) {\n"
    "      addCanvasNoise(this, PROFILE.canvasSeed);\n"
    "      return originalToDataURL.apply(this, args);\n"
    "    };\n"
    "    \n"
    "    HTMLCanvasElement.prototype.toBlob = function(...args) {\n"
    "      addCanvasNoise(this, PROFILE.canvasSeed);\n"
    "      return originalToBlob.apply(this, args);\n"
    "    };\n"
    "    \n"
    "    CanvasRenderingContext2D.prototype.getImageData = function(...args) {\n"
    "      const imageData = originalGetImageData.apply(this, args);\n"
    "      const data = imageData.data;\n"
    "      \n"
    "      // Add minimal noise\n"
    "      let rng = PROFILE.canvasSeed;\n"
    "      for (let i = 0; i < data.length; i += 500) {\n"
    "        rng = (rng * 9301 + 49297) %% 233280;\n"
    "        const noise = (rng / 233280.0) - 0.5;\n"
    "        data[i] = Math.max(0, Math.min(255, data[i] + noise));\n"
    "      }\n"
    "      \n"
    "      return imageData;\n"
    "    };\n"
    "  } catch(e) { console.error('Canvas protection failed:', e); }\n"
    "  \n"
    "  // ========== WebGL Fingerprinting Protection ==========\n"
    "  try {\n"
    "    const getParameter = WebGLRenderingContext.prototype.getParameter;\n"
    "    WebGLRenderingContext.prototype.getParameter = function(parameter) {\n"
    "      // UNMASKED_VENDOR_WEBGL\n"
    "      if (parameter === 37445) return PROFILE.webglVendor;\n"
    "      // UNMASKED_RENDERER_WEBGL\n"
    "      if (parameter === 37446) return PROFILE.webglRenderer;\n"
    "      return getParameter.apply(this, arguments);\n"
    "    };\n"
    "    \n"
    "    // Also for WebGL2\n"
    "    if (typeof WebGL2RenderingContext !== 'undefined') {\n"
    "      const getParameter2 = WebGL2RenderingContext.prototype.getParameter;\n"
    "      WebGL2RenderingContext.prototype.getParameter = function(parameter) {\n"
    "        if (parameter === 37445) return PROFILE.webglVendor;\n"
    "        if (parameter === 37446) return PROFILE.webglRenderer;\n"
    "        return getParameter2.apply(this, arguments);\n"
    "      };\n"
    "    }\n"
    "    \n"
    "    // Spoof supported extensions\n"
    "    const getSupportedExtensions = WebGLRenderingContext.prototype.getSupportedExtensions;\n"
    "    WebGLRenderingContext.prototype.getSupportedExtensions = function() {\n"
    "      const extensions = getSupportedExtensions.apply(this, arguments);\n"
    "      // Return a consistent subset\n"
    "      const commonExtensions = [\n"
    "        'ANGLE_instanced_arrays',\n"
    "        'EXT_blend_minmax',\n"
    "        'EXT_color_buffer_half_float',\n"
    "        'EXT_frag_depth',\n"
    "        'EXT_shader_texture_lod',\n"
    "        'EXT_texture_filter_anisotropic',\n"
    "        'OES_element_index_uint',\n"
    "        'OES_standard_derivatives',\n"
    "        'OES_texture_float',\n"
    "        'OES_texture_half_float',\n"
    "        'OES_vertex_array_object',\n"
    "        'WEBGL_compressed_texture_s3tc',\n"
    "        'WEBGL_debug_renderer_info',\n"
    "        'WEBGL_depth_texture',\n"
    "        'WEBGL_lose_context'\n"
    "      ];\n"
    "      return extensions ? extensions.filter(e => commonExtensions.includes(e)) : commonExtensions;\n"
    "    };\n"
    "  } catch(e) { console.error('WebGL protection failed:', e); }\n"
    "  \n"
    "  // ========== AudioContext Fingerprinting Protection ==========\n"
    "  try {\n"
    "    const AudioContext = window.AudioContext || window.webkitAudioContext;\n"
    "    if (AudioContext) {\n"
    "      const originalCreateAnalyser = AudioContext.prototype.createAnalyser;\n"
    "      AudioContext.prototype.createAnalyser = function() {\n"
    "        const analyser = originalCreateAnalyser.apply(this, arguments);\n"
    "        const originalGetFloatTimeDomainData = analyser.getFloatTimeDomainData;\n"
    "        \n"
    "        analyser.getFloatTimeDomainData = function(array) {\n"
    "          originalGetFloatTimeDomainData.apply(this, arguments);\n"
    "          // Add minimal noise\n"
    "          let rng = PROFILE.audioSeed;\n"
    "          for (let i = 0; i < array.length; i += 10) {\n"
    "            rng = (rng * 9301 + 49297) %% 233280;\n"
    "            const noise = (rng / 233280.0 - 0.5) * 0.0001;\n"
    "            array[i] = array[i] + noise;\n"
    "          }\n"
    "        };\n"
    "        \n"
    "        return analyser;\n"
    "      };\n"
    "    }\n"
    "  } catch(e) { console.error('Audio protection failed:', e); }\n"
    "  \n"
    "  // ========== Font Enumeration Blocking ==========\n"
    "  try {\n"
    "    if (document.fonts && document.fonts.check) {\n"
    "      const commonFonts = [\n"
    "        'Arial', 'Verdana', 'Helvetica', 'Times New Roman',\n"
    "        'Courier New', 'Georgia', 'Palatino', 'Garamond',\n"
    "        'Comic Sans MS', 'Trebuchet MS', 'Impact'\n"
    "      ];\n"
    "      \n"
    "      const originalCheck = document.fonts.check;\n"
    "      document.fonts.check = function(font, text) {\n"
    "        // Only report common fonts as available\n"
    "        const fontFamily = font.match(/['\"]?([^'\"]+)['\"]?/)?.[1];\n"
    "        if (fontFamily && commonFonts.includes(fontFamily)) {\n"
    "          return true;\n"
    "        }\n"
    "        return false;\n"
    "      };\n"
    "    }\n"
    "  } catch(e) { console.error('Font blocking failed:', e); }\n"
    "  \n"
    "  // ========== High-Resolution Timer Protection ==========\n"
    "  try {\n"
    "    const originalNow = performance.now;\n"
    "    let timeOffset = 0;\n"
    "    \n"
    "    performance.now = function() {\n"
    "      const realTime = originalNow.apply(this, arguments);\n"
    "      // Reduce precision to 100 microseconds and add jitter\n"
    "      const quantized = Math.floor(realTime * 10) / 10;\n"
    "      let rng = PROFILE.canvasSeed + Math.floor(realTime);\n"
    "      rng = (rng * 9301 + 49297) %% 233280;\n"
    "      const jitter = (rng / 233280.0 - 0.5) * 0.1;\n"
    "      return quantized + jitter;\n"
    "    };\n"
    "  } catch(e) { console.error('Timer protection failed:', e); }\n"
    "  \n"
    "  // ========== Battery API Blocking ==========\n"
    "  try {\n"
    "    if (navigator.getBattery) {\n"
    "      navigator.getBattery = function() {\n"
    "        return Promise.reject(new Error('Battery API not available'));\n"
    "      };\n"
    "    }\n"
    "  } catch(e) {}\n"
    "  \n"
    "  // ========== Sensor APIs Blocking ==========\n"
    "  try {\n"
    "    // Block DeviceOrientation and DeviceMotion\n"
    "    window.DeviceOrientationEvent = undefined;\n"
    "    window.DeviceMotionEvent = undefined;\n"
    "    \n"
    "    // Block Ambient Light Sensor\n"
    "    if (window.AmbientLightSensor) {\n"
    "      window.AmbientLightSensor = undefined;\n"
    "    }\n"
    "  } catch(e) {}\n"
    "  \n"
    "  // ========== WebRTC Protection ==========\n"
    "  try {\n"
    "    // Block local IP leak via ICE candidates\n"
    "    if (typeof RTCPeerConnection !== 'undefined') {\n"
    "      const OriginalRTCPeerConnection = RTCPeerConnection;\n"
    "      \n"
    "      RTCPeerConnection = function(...args) {\n"
    "        const pc = new OriginalRTCPeerConnection(...args);\n"
    "        \n"
    "        // Intercept onicecandidate\n"
    "        const originalOnIceCandidate = pc.onicecandidate;\n"
    "        pc.onicecandidate = function(event) {\n"
    "          if (event.candidate) {\n"
    "            const candidate = event.candidate.candidate;\n"
    "            // Block local IP addresses (192.168.x.x, 10.x.x.x, etc.)\n"
    "            if (candidate && (candidate.includes('192.168.') || \n"
    "                              candidate.includes('10.') ||\n"
    "                              candidate.includes('172.16.') ||\n"
    "                              candidate.includes('172.17.') ||\n"
    "                              candidate.includes('172.18.') ||\n"
    "                              candidate.includes('172.19.') ||\n"
    "                              candidate.includes('172.2') ||\n"
    "                              candidate.includes('172.3') ||\n"
    "                              candidate.match(/([0-9]{1,3}(\\.[0-9]{1,3}){3}|[a-f0-9]{1,4}(:[a-f0-9]{1,4}){7})/))) {\n"
    "              // Filter out local IPs\n"
    "              return;\n"
    "            }\n"
    "          }\n"
    "          if (originalOnIceCandidate) {\n"
    "            return originalOnIceCandidate.apply(this, arguments);\n"
    "          }\n"
    "        };\n"
    "        \n"
    "        return pc;\n"
    "      };\n"
    "      RTCPeerConnection.prototype = OriginalRTCPeerConnection.prototype;\n"
    "    }\n"
    "    \n"
    "    // Spoof mediaDevices.enumerateDevices\n"
    "    if (navigator.mediaDevices && navigator.mediaDevices.enumerateDevices) {\n"
    "      navigator.mediaDevices.enumerateDevices = function() {\n"
    "        return Promise.resolve([\n"
    "          {deviceId: 'default', kind: 'audioinput', label: '', groupId: 'default'},\n"
    "          {deviceId: 'default', kind: 'audiooutput', label: '', groupId: 'default'},\n"
    "          {deviceId: 'default', kind: 'videoinput', label: '', groupId: 'default'}\n"
    "        ]);\n"
    "      };\n"
    "    }\n"
    "  } catch(e) { console.error('WebRTC protection failed:', e); }\n"
    "  \n"
    "  console.log('Privacy protection active: Profile', '%s');\n"
    "})();\n",
    profile->user_agent,
    profile->platform,
    profile->hardware_concurrency,
    profile->device_memory,
    langs_str->str,
    profile->language,
    profile->max_touch_points,
    profile->vendor,
    profile->screen_width,
    profile->screen_height,
    profile->screen_avail_width,
    profile->screen_avail_height,
    profile->device_pixel_ratio,
    profile->color_depth,
    profile->timezone,
    profile->webgl_vendor,
    profile->webgl_renderer,
    profile->canvas_seed,
    profile->audio_seed,
    profile->profile_name
  );
  
  g_string_free(langs_str, TRUE);
  return script;
}

void free_privacy_script(gchar *script) {
  g_free(script);
}
